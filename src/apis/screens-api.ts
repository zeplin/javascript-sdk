/* tslint:disable */
/* eslint-disable */
/**
 * Zeplin API
 * Access your resources in Zeplin
 *
 * Contact: support@zeplin.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import globalAxios, { AxiosPromise, AxiosInstance, AxiosResponse } from 'axios';
import FormData from 'form-data';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import {
    CommentCreateBody,
    transformCommentCreateBodyToJSON,
    transformJSONToCommentCreateBody
} from '../models';
// @ts-ignore
import {
    CommentUpdateBody,
    transformCommentUpdateBodyToJSON,
    transformJSONToCommentUpdateBody
} from '../models';
// @ts-ignore
import {
    Component,
    transformComponentToJSON,
    transformJSONToComponent
} from '../models';
// @ts-ignore
import {
    EntityReference,
    transformEntityReferenceToJSON,
    transformJSONToEntityReference
} from '../models';
// @ts-ignore
import {
    ErrorResponse,
    transformErrorResponseToJSON,
    transformJSONToErrorResponse
} from '../models';
// @ts-ignore
import {
    Screen,
    transformScreenToJSON,
    transformJSONToScreen
} from '../models';
// @ts-ignore
import {
    ScreenAnnotation,
    transformScreenAnnotationToJSON,
    transformJSONToScreenAnnotation
} from '../models';
// @ts-ignore
import {
    ScreenAnnotationCreateBody,
    transformScreenAnnotationCreateBodyToJSON,
    transformJSONToScreenAnnotationCreateBody
} from '../models';
// @ts-ignore
import {
    ScreenAnnotationNoteType,
    transformScreenAnnotationNoteTypeToJSON,
    transformJSONToScreenAnnotationNoteType
} from '../models';
// @ts-ignore
import {
    ScreenAnnotationUpdateBody,
    transformScreenAnnotationUpdateBodyToJSON,
    transformJSONToScreenAnnotationUpdateBody
} from '../models';
// @ts-ignore
import {
    ScreenNote,
    transformScreenNoteToJSON,
    transformJSONToScreenNote
} from '../models';
// @ts-ignore
import {
    ScreenNoteCreateBody,
    transformScreenNoteCreateBodyToJSON,
    transformJSONToScreenNoteCreateBody
} from '../models';
// @ts-ignore
import {
    ScreenNoteUpdateBody,
    transformScreenNoteUpdateBodyToJSON,
    transformJSONToScreenNoteUpdateBody
} from '../models';
// @ts-ignore
import {
    ScreenSection,
    transformScreenSectionToJSON,
    transformJSONToScreenSection
} from '../models';
// @ts-ignore
import {
    ScreenUpdateBody,
    transformScreenUpdateBodyToJSON,
    transformJSONToScreenUpdateBody
} from '../models';
// @ts-ignore
import {
    ScreenVariantGroup,
    transformScreenVariantGroupToJSON,
    transformJSONToScreenVariantGroup
} from '../models';
// @ts-ignore
import {
    ScreenVersion,
    transformScreenVersionToJSON,
    transformJSONToScreenVersion
} from '../models';
// @ts-ignore
import {
    ScreenVersionSummary,
    transformScreenVersionSummaryToJSON,
    transformJSONToScreenVersionSummary
} from '../models';
/**
 * ScreensApi - axios parameter creator
 * @export
 */
export const ScreensApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new screen in the project
         * @summary Create a new screen
         * @param {string} projectId Project id
         * @param {string} name Name of the screen
         * @param {any} image Binary data of the screen image.  The image has to be in JPEG or PNG format, and its size cannot exceed 5MB. 
         * @param {string} [description] Description for the screen
         * @param {string} [commitMessage] Commit message for the screen version
         * @param {string} [commitColor] Commit color for the screen version
         * @param {Array<string>} [tags] Tags for the screen
         * @param {string} [sectionId] Unique id of the screen section
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createScreen: async (projectId: string, name: string, image: any, description?: string, commitMessage?: string, commitColor?: string, tags?: Array<string>, sectionId?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('createScreen', 'projectId', projectId)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('createScreen', 'name', name)
            // verify required parameter 'image' is not null or undefined
            assertParamExists('createScreen', 'image', image)
            const localVarPath = `/v1/projects/{project_id}/screens`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new FormData();

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication PersonalAccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

    
            if (name !== undefined) { 
                localVarFormParams.append('name', name as any);
            }
    
            if (image !== undefined) { 
                localVarFormParams.append('image', image.file as any, `image.${image.type}`);
            }
    
            if (description !== undefined) { 
                localVarFormParams.append('description', description as any);
            }
    
            if (commitMessage !== undefined) { 
                localVarFormParams.append('commit_message', commitMessage as any);
            }
    
            if (commitColor !== undefined) { 
                localVarFormParams.append('commit_color', commitColor as any);
            }
    
            if (tags) {

                localVarFormParams.append('tags', tags.join(COLLECTION_FORMATS.csv));
            }

    
            if (sectionId !== undefined) { 
                localVarFormParams.append('section_id', sectionId as any);
            }
    
    
            if (localVarFormParams.getHeaders) {
                Object.assign(localVarHeaderParameter, localVarFormParams.getHeaders());
            } else {
                localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
            }
    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create an annotation on the screen
         * @summary Create an annotation
         * @param {string} projectId Project id
         * @param {string} screenId Screen id
         * @param {ScreenAnnotationCreateBody} screenAnnotationCreateBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createScreenAnnotation: async (projectId: string, screenId: string, screenAnnotationCreateBody: ScreenAnnotationCreateBody, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('createScreenAnnotation', 'projectId', projectId)
            // verify required parameter 'screenId' is not null or undefined
            assertParamExists('createScreenAnnotation', 'screenId', screenId)
            // verify required parameter 'screenAnnotationCreateBody' is not null or undefined
            assertParamExists('createScreenAnnotation', 'screenAnnotationCreateBody', screenAnnotationCreateBody)
            const localVarPath = `/v1/projects/{project_id}/screens/{screen_id}/annotations`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"screen_id"}}`, encodeURIComponent(String(screenId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication PersonalAccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

    
    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(transformScreenAnnotationCreateBodyToJSON(screenAnnotationCreateBody), localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create comment on the screen note
         * @summary Create a comment
         * @param {string} projectId Project id
         * @param {string} screenId Screen id
         * @param {string} noteId Screen note id
         * @param {CommentCreateBody} commentCreateBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createScreenComment: async (projectId: string, screenId: string, noteId: string, commentCreateBody: CommentCreateBody, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('createScreenComment', 'projectId', projectId)
            // verify required parameter 'screenId' is not null or undefined
            assertParamExists('createScreenComment', 'screenId', screenId)
            // verify required parameter 'noteId' is not null or undefined
            assertParamExists('createScreenComment', 'noteId', noteId)
            // verify required parameter 'commentCreateBody' is not null or undefined
            assertParamExists('createScreenComment', 'commentCreateBody', commentCreateBody)
            const localVarPath = `/v1/projects/{project_id}/screens/{screen_id}/notes/{note_id}/comments`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"screen_id"}}`, encodeURIComponent(String(screenId)))
                .replace(`{${"note_id"}}`, encodeURIComponent(String(noteId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication PersonalAccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

    
    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(transformCommentCreateBodyToJSON(commentCreateBody), localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a note on the screen
         * @summary Create a note
         * @param {string} projectId Project id
         * @param {string} screenId Screen id
         * @param {ScreenNoteCreateBody} screenNoteCreateBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createScreenNote: async (projectId: string, screenId: string, screenNoteCreateBody: ScreenNoteCreateBody, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('createScreenNote', 'projectId', projectId)
            // verify required parameter 'screenId' is not null or undefined
            assertParamExists('createScreenNote', 'screenId', screenId)
            // verify required parameter 'screenNoteCreateBody' is not null or undefined
            assertParamExists('createScreenNote', 'screenNoteCreateBody', screenNoteCreateBody)
            const localVarPath = `/v1/projects/{project_id}/screens/{screen_id}/notes`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"screen_id"}}`, encodeURIComponent(String(screenId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication PersonalAccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

    
    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(transformScreenNoteCreateBodyToJSON(screenNoteCreateBody), localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new screen version in the project
         * @summary Create a new screen version
         * @param {string} projectId Project id
         * @param {string} screenId Screen id
         * @param {any} image Binary data of the screen image.  The image has to be in JPEG or PNG format, and its size cannot exceed 5MB. 
         * @param {string} [commitMessage] Commit message for the screen version
         * @param {string} [commitColor] Commit color for the screen version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createScreenVersion: async (projectId: string, screenId: string, image: any, commitMessage?: string, commitColor?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('createScreenVersion', 'projectId', projectId)
            // verify required parameter 'screenId' is not null or undefined
            assertParamExists('createScreenVersion', 'screenId', screenId)
            // verify required parameter 'image' is not null or undefined
            assertParamExists('createScreenVersion', 'image', image)
            const localVarPath = `/v1/projects/{project_id}/screens/{screen_id}/versions`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"screen_id"}}`, encodeURIComponent(String(screenId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new FormData();

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication PersonalAccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

    
            if (image !== undefined) { 
                localVarFormParams.append('image', image.file as any, `image.${image.type}`);
            }
    
            if (commitMessage !== undefined) { 
                localVarFormParams.append('commit_message', commitMessage as any);
            }
    
            if (commitColor !== undefined) { 
                localVarFormParams.append('commit_color', commitColor as any);
            }
    
    
            if (localVarFormParams.getHeaders) {
                Object.assign(localVarHeaderParameter, localVarFormParams.getHeaders());
            } else {
                localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
            }
    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an annotation on the screen
         * @summary Delete an annotation
         * @param {string} projectId Project id
         * @param {string} screenId Screen id
         * @param {string} annotationId Screen annotation id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteScreenAnnotation: async (projectId: string, screenId: string, annotationId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('deleteScreenAnnotation', 'projectId', projectId)
            // verify required parameter 'screenId' is not null or undefined
            assertParamExists('deleteScreenAnnotation', 'screenId', screenId)
            // verify required parameter 'annotationId' is not null or undefined
            assertParamExists('deleteScreenAnnotation', 'annotationId', annotationId)
            const localVarPath = `/v1/projects/{project_id}/screens/{screen_id}/annotations/{annotation_id}`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"screen_id"}}`, encodeURIComponent(String(screenId)))
                .replace(`{${"annotation_id"}}`, encodeURIComponent(String(annotationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication PersonalAccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

    
    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a comment on the screen note
         * @summary Delete comment
         * @param {string} projectId Project id
         * @param {string} screenId Screen id
         * @param {string} noteId Screen note id
         * @param {string} commentId Screen comment id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteScreenComment: async (projectId: string, screenId: string, noteId: string, commentId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('deleteScreenComment', 'projectId', projectId)
            // verify required parameter 'screenId' is not null or undefined
            assertParamExists('deleteScreenComment', 'screenId', screenId)
            // verify required parameter 'noteId' is not null or undefined
            assertParamExists('deleteScreenComment', 'noteId', noteId)
            // verify required parameter 'commentId' is not null or undefined
            assertParamExists('deleteScreenComment', 'commentId', commentId)
            const localVarPath = `/v1/projects/{project_id}/screens/{screen_id}/notes/{note_id}/comments/{comment_id}`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"screen_id"}}`, encodeURIComponent(String(screenId)))
                .replace(`{${"note_id"}}`, encodeURIComponent(String(noteId)))
                .replace(`{${"comment_id"}}`, encodeURIComponent(String(commentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication PersonalAccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

    
    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a note on the screen
         * @summary Delete a note
         * @param {string} projectId Project id
         * @param {string} screenId Screen id
         * @param {string} noteId Screen note id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteScreenNote: async (projectId: string, screenId: string, noteId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('deleteScreenNote', 'projectId', projectId)
            // verify required parameter 'screenId' is not null or undefined
            assertParamExists('deleteScreenNote', 'screenId', screenId)
            // verify required parameter 'noteId' is not null or undefined
            assertParamExists('deleteScreenNote', 'noteId', noteId)
            const localVarPath = `/v1/projects/{project_id}/screens/{screen_id}/notes/{note_id}`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"screen_id"}}`, encodeURIComponent(String(screenId)))
                .replace(`{${"note_id"}}`, encodeURIComponent(String(noteId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication PersonalAccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

    
    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get details of the latest version
         * @summary Get the latest screen version
         * @param {string} projectId Project id
         * @param {string} screenId Screen id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestScreenVersion: async (projectId: string, screenId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getLatestScreenVersion', 'projectId', projectId)
            // verify required parameter 'screenId' is not null or undefined
            assertParamExists('getLatestScreenVersion', 'screenId', screenId)
            const localVarPath = `/v1/projects/{project_id}/screens/{screen_id}/versions/latest`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"screen_id"}}`, encodeURIComponent(String(screenId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication PersonalAccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

    
    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all screens of the project
         * @summary Get project screens
         * @param {string} projectId Project id
         * @param {string} [sectionId] Filter by section id
         * @param {'section' | 'created'} [sort] Sort screens by their &#x60;section&#x60; or their &#x60;created&#x60; date
         * @param {number} [limit] Pagination limit
         * @param {number} [offset] Pagination offset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectScreens: async (projectId: string, sectionId?: string, sort?: 'section' | 'created', limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getProjectScreens', 'projectId', projectId)
            const localVarPath = `/v1/projects/{project_id}/screens`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication PersonalAccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (sectionId !== undefined) {
                localVarQueryParameter['section_id'] = sectionId;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

    
    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a single screen by id
         * @summary Get a single screen
         * @param {string} projectId Project id
         * @param {string} screenId Screen id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScreen: async (projectId: string, screenId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getScreen', 'projectId', projectId)
            // verify required parameter 'screenId' is not null or undefined
            assertParamExists('getScreen', 'screenId', screenId)
            const localVarPath = `/v1/projects/{project_id}/screens/{screen_id}`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"screen_id"}}`, encodeURIComponent(String(screenId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication PersonalAccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

    
    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a screen annotation by id
         * @summary Get a single screen annotation
         * @param {string} projectId Project id
         * @param {string} screenId Screen id
         * @param {string} annotationId Screen annotation id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScreenAnnotation: async (projectId: string, screenId: string, annotationId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getScreenAnnotation', 'projectId', projectId)
            // verify required parameter 'screenId' is not null or undefined
            assertParamExists('getScreenAnnotation', 'screenId', screenId)
            // verify required parameter 'annotationId' is not null or undefined
            assertParamExists('getScreenAnnotation', 'annotationId', annotationId)
            const localVarPath = `/v1/projects/{project_id}/screens/{screen_id}/annotations/{annotation_id}`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"screen_id"}}`, encodeURIComponent(String(screenId)))
                .replace(`{${"annotation_id"}}`, encodeURIComponent(String(annotationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication PersonalAccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

    
    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all annotations in the screen
         * @summary Get screen annotations
         * @param {string} projectId Project id
         * @param {string} screenId Screen id
         * @param {number} [limit] Pagination limit
         * @param {number} [offset] Pagination offset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScreenAnnotations: async (projectId: string, screenId: string, limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getScreenAnnotations', 'projectId', projectId)
            // verify required parameter 'screenId' is not null or undefined
            assertParamExists('getScreenAnnotations', 'screenId', screenId)
            const localVarPath = `/v1/projects/{project_id}/screens/{screen_id}/annotations`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"screen_id"}}`, encodeURIComponent(String(screenId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication PersonalAccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

    
    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all annotation note types in the project
         * @summary Get screen annotation note types
         * @param {string} projectId Project id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScreenAnnotationsNoteTypes: async (projectId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getScreenAnnotationsNoteTypes', 'projectId', projectId)
            const localVarPath = `/v1/projects/{project_id}/annotations/note_types`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication PersonalAccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

    
    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all components in the screen
         * @summary Get screen components
         * @param {string} projectId Project id
         * @param {string} screenId Screen id
         * @param {number} [limit] Pagination limit
         * @param {number} [offset] Pagination offset
         * @param {boolean} [includeLatestVersion] Whether to include the latest version data in the Component object
         * @param {boolean} [includeLinkedStyleguides] Whether to include linked styleguides or not
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScreenComponents: async (projectId: string, screenId: string, limit?: number, offset?: number, includeLatestVersion?: boolean, includeLinkedStyleguides?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getScreenComponents', 'projectId', projectId)
            // verify required parameter 'screenId' is not null or undefined
            assertParamExists('getScreenComponents', 'screenId', screenId)
            const localVarPath = `/v1/projects/{project_id}/screens/{screen_id}/components`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"screen_id"}}`, encodeURIComponent(String(screenId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication PersonalAccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (includeLatestVersion !== undefined) {
                localVarQueryParameter['include_latest_version'] = includeLatestVersion;
            }

            if (includeLinkedStyleguides !== undefined) {
                localVarQueryParameter['include_linked_styleguides'] = includeLinkedStyleguides;
            }

    
    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a screen note by id
         * @summary Get a single screen note
         * @param {string} projectId Project id
         * @param {string} screenId Screen id
         * @param {string} noteId Screen note id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScreenNote: async (projectId: string, screenId: string, noteId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getScreenNote', 'projectId', projectId)
            // verify required parameter 'screenId' is not null or undefined
            assertParamExists('getScreenNote', 'screenId', screenId)
            // verify required parameter 'noteId' is not null or undefined
            assertParamExists('getScreenNote', 'noteId', noteId)
            const localVarPath = `/v1/projects/{project_id}/screens/{screen_id}/notes/{note_id}`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"screen_id"}}`, encodeURIComponent(String(screenId)))
                .replace(`{${"note_id"}}`, encodeURIComponent(String(noteId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication PersonalAccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

    
    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all notes in the screen
         * @summary Get screen notes
         * @param {string} projectId Project id
         * @param {string} screenId Screen id
         * @param {number} [limit] Pagination limit
         * @param {number} [offset] Pagination offset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScreenNotes: async (projectId: string, screenId: string, limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getScreenNotes', 'projectId', projectId)
            // verify required parameter 'screenId' is not null or undefined
            assertParamExists('getScreenNotes', 'screenId', screenId)
            const localVarPath = `/v1/projects/{project_id}/screens/{screen_id}/notes`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"screen_id"}}`, encodeURIComponent(String(screenId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication PersonalAccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

    
    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a screen section by id
         * @summary Get a single screen section
         * @param {string} projectId Project id
         * @param {string} sectionId Screen section id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScreenSection: async (projectId: string, sectionId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getScreenSection', 'projectId', projectId)
            // verify required parameter 'sectionId' is not null or undefined
            assertParamExists('getScreenSection', 'sectionId', sectionId)
            const localVarPath = `/v1/projects/{project_id}/screen_sections/{section_id}`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"section_id"}}`, encodeURIComponent(String(sectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication PersonalAccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

    
    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all screen sections of the project
         * @summary Get screen sections
         * @param {string} projectId Project id
         * @param {number} [limit] Pagination limit
         * @param {number} [offset] Pagination offset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScreenSections: async (projectId: string, limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getScreenSections', 'projectId', projectId)
            const localVarPath = `/v1/projects/{project_id}/screen_sections`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication PersonalAccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

    
    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a screen variant by id
         * @summary Get a single screen variant
         * @param {string} projectId Project id
         * @param {string} variantId Screen variant id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScreenVariant: async (projectId: string, variantId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getScreenVariant', 'projectId', projectId)
            // verify required parameter 'variantId' is not null or undefined
            assertParamExists('getScreenVariant', 'variantId', variantId)
            const localVarPath = `/v1/projects/{project_id}/screen_variants/{variant_id}`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"variant_id"}}`, encodeURIComponent(String(variantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication PersonalAccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

    
    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all screen variants of the project
         * @summary Get screen variants
         * @param {string} projectId Project id
         * @param {number} [limit] Pagination limit
         * @param {number} [offset] Pagination offset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScreenVariants: async (projectId: string, limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getScreenVariants', 'projectId', projectId)
            const localVarPath = `/v1/projects/{project_id}/screen_variants`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication PersonalAccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

    
    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get details of the screen version
         * @summary Get a single screen version
         * @param {string} projectId Project id
         * @param {string} screenId Screen id
         * @param {string} versionId Screen version id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScreenVersion: async (projectId: string, screenId: string, versionId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getScreenVersion', 'projectId', projectId)
            // verify required parameter 'screenId' is not null or undefined
            assertParamExists('getScreenVersion', 'screenId', screenId)
            // verify required parameter 'versionId' is not null or undefined
            assertParamExists('getScreenVersion', 'versionId', versionId)
            const localVarPath = `/v1/projects/{project_id}/screens/{screen_id}/versions/{version_id}`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"screen_id"}}`, encodeURIComponent(String(screenId)))
                .replace(`{${"version_id"}}`, encodeURIComponent(String(versionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication PersonalAccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

    
    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all versions of the screen in a project
         * @summary Get screen versions
         * @param {string} projectId Project id
         * @param {string} screenId Screen id
         * @param {number} [limit] Pagination limit
         * @param {number} [offset] Pagination offset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScreenVersions: async (projectId: string, screenId: string, limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getScreenVersions', 'projectId', projectId)
            // verify required parameter 'screenId' is not null or undefined
            assertParamExists('getScreenVersions', 'screenId', screenId)
            const localVarPath = `/v1/projects/{project_id}/screens/{screen_id}/versions`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"screen_id"}}`, encodeURIComponent(String(screenId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication PersonalAccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

    
    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a screen\'s description
         * @summary Update a screen
         * @param {string} projectId Project id
         * @param {string} screenId Screen id
         * @param {ScreenUpdateBody} screenUpdateBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateScreen: async (projectId: string, screenId: string, screenUpdateBody: ScreenUpdateBody, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('updateScreen', 'projectId', projectId)
            // verify required parameter 'screenId' is not null or undefined
            assertParamExists('updateScreen', 'screenId', screenId)
            // verify required parameter 'screenUpdateBody' is not null or undefined
            assertParamExists('updateScreen', 'screenUpdateBody', screenUpdateBody)
            const localVarPath = `/v1/projects/{project_id}/screens/{screen_id}`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"screen_id"}}`, encodeURIComponent(String(screenId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication PersonalAccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

    
    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(transformScreenUpdateBodyToJSON(screenUpdateBody), localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an annotation on the screen
         * @summary Update an annotation
         * @param {string} projectId Project id
         * @param {string} screenId Screen id
         * @param {string} annotationId Screen annotation id
         * @param {ScreenAnnotationUpdateBody} screenAnnotationUpdateBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateScreenAnnotation: async (projectId: string, screenId: string, annotationId: string, screenAnnotationUpdateBody: ScreenAnnotationUpdateBody, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('updateScreenAnnotation', 'projectId', projectId)
            // verify required parameter 'screenId' is not null or undefined
            assertParamExists('updateScreenAnnotation', 'screenId', screenId)
            // verify required parameter 'annotationId' is not null or undefined
            assertParamExists('updateScreenAnnotation', 'annotationId', annotationId)
            // verify required parameter 'screenAnnotationUpdateBody' is not null or undefined
            assertParamExists('updateScreenAnnotation', 'screenAnnotationUpdateBody', screenAnnotationUpdateBody)
            const localVarPath = `/v1/projects/{project_id}/screens/{screen_id}/annotations/{annotation_id}`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"screen_id"}}`, encodeURIComponent(String(screenId)))
                .replace(`{${"annotation_id"}}`, encodeURIComponent(String(annotationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication PersonalAccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

    
    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(transformScreenAnnotationUpdateBodyToJSON(screenAnnotationUpdateBody), localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update comments on the screen note
         * @summary Update comment
         * @param {string} projectId Project id
         * @param {string} screenId Screen id
         * @param {string} noteId Screen note id
         * @param {string} commentId Screen comment id
         * @param {CommentUpdateBody} commentUpdateBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateScreenComment: async (projectId: string, screenId: string, noteId: string, commentId: string, commentUpdateBody: CommentUpdateBody, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('updateScreenComment', 'projectId', projectId)
            // verify required parameter 'screenId' is not null or undefined
            assertParamExists('updateScreenComment', 'screenId', screenId)
            // verify required parameter 'noteId' is not null or undefined
            assertParamExists('updateScreenComment', 'noteId', noteId)
            // verify required parameter 'commentId' is not null or undefined
            assertParamExists('updateScreenComment', 'commentId', commentId)
            // verify required parameter 'commentUpdateBody' is not null or undefined
            assertParamExists('updateScreenComment', 'commentUpdateBody', commentUpdateBody)
            const localVarPath = `/v1/projects/{project_id}/screens/{screen_id}/notes/{note_id}/comments/{comment_id}`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"screen_id"}}`, encodeURIComponent(String(screenId)))
                .replace(`{${"note_id"}}`, encodeURIComponent(String(noteId)))
                .replace(`{${"comment_id"}}`, encodeURIComponent(String(commentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication PersonalAccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

    
    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(transformCommentUpdateBodyToJSON(commentUpdateBody), localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a note on the screen
         * @summary Update a note
         * @param {string} projectId Project id
         * @param {string} screenId Screen id
         * @param {string} noteId Screen note id
         * @param {ScreenNoteUpdateBody} screenNoteUpdateBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateScreenNote: async (projectId: string, screenId: string, noteId: string, screenNoteUpdateBody: ScreenNoteUpdateBody, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('updateScreenNote', 'projectId', projectId)
            // verify required parameter 'screenId' is not null or undefined
            assertParamExists('updateScreenNote', 'screenId', screenId)
            // verify required parameter 'noteId' is not null or undefined
            assertParamExists('updateScreenNote', 'noteId', noteId)
            // verify required parameter 'screenNoteUpdateBody' is not null or undefined
            assertParamExists('updateScreenNote', 'screenNoteUpdateBody', screenNoteUpdateBody)
            const localVarPath = `/v1/projects/{project_id}/screens/{screen_id}/notes/{note_id}`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"screen_id"}}`, encodeURIComponent(String(screenId)))
                .replace(`{${"note_id"}}`, encodeURIComponent(String(noteId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication PersonalAccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

    
    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(transformScreenNoteUpdateBodyToJSON(screenNoteUpdateBody), localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ScreensApi - functional programming interface
 * @export
 */
export const ScreensApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ScreensApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new screen in the project
         * @summary Create a new screen
         * @param {string} projectId Project id
         * @param {string} name Name of the screen
         * @param {any} image Binary data of the screen image.  The image has to be in JPEG or PNG format, and its size cannot exceed 5MB. 
         * @param {string} [description] Description for the screen
         * @param {string} [commitMessage] Commit message for the screen version
         * @param {string} [commitColor] Commit color for the screen version
         * @param {Array<string>} [tags] Tags for the screen
         * @param {string} [sectionId] Unique id of the screen section
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createScreen(projectId: string, name: string, image: any, description?: string, commitMessage?: string, commitColor?: string, tags?: Array<string>, sectionId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createScreen(projectId, name, image, description, commitMessage, commitColor, tags, sectionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create an annotation on the screen
         * @summary Create an annotation
         * @param {string} projectId Project id
         * @param {string} screenId Screen id
         * @param {ScreenAnnotationCreateBody} screenAnnotationCreateBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createScreenAnnotation(projectId: string, screenId: string, screenAnnotationCreateBody: ScreenAnnotationCreateBody, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createScreenAnnotation(projectId, screenId, screenAnnotationCreateBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create comment on the screen note
         * @summary Create a comment
         * @param {string} projectId Project id
         * @param {string} screenId Screen id
         * @param {string} noteId Screen note id
         * @param {CommentCreateBody} commentCreateBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createScreenComment(projectId: string, screenId: string, noteId: string, commentCreateBody: CommentCreateBody, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createScreenComment(projectId, screenId, noteId, commentCreateBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a note on the screen
         * @summary Create a note
         * @param {string} projectId Project id
         * @param {string} screenId Screen id
         * @param {ScreenNoteCreateBody} screenNoteCreateBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createScreenNote(projectId: string, screenId: string, screenNoteCreateBody: ScreenNoteCreateBody, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createScreenNote(projectId, screenId, screenNoteCreateBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new screen version in the project
         * @summary Create a new screen version
         * @param {string} projectId Project id
         * @param {string} screenId Screen id
         * @param {any} image Binary data of the screen image.  The image has to be in JPEG or PNG format, and its size cannot exceed 5MB. 
         * @param {string} [commitMessage] Commit message for the screen version
         * @param {string} [commitColor] Commit color for the screen version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createScreenVersion(projectId: string, screenId: string, image: any, commitMessage?: string, commitColor?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createScreenVersion(projectId, screenId, image, commitMessage, commitColor, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete an annotation on the screen
         * @summary Delete an annotation
         * @param {string} projectId Project id
         * @param {string} screenId Screen id
         * @param {string} annotationId Screen annotation id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteScreenAnnotation(projectId: string, screenId: string, annotationId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteScreenAnnotation(projectId, screenId, annotationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a comment on the screen note
         * @summary Delete comment
         * @param {string} projectId Project id
         * @param {string} screenId Screen id
         * @param {string} noteId Screen note id
         * @param {string} commentId Screen comment id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteScreenComment(projectId: string, screenId: string, noteId: string, commentId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteScreenComment(projectId, screenId, noteId, commentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a note on the screen
         * @summary Delete a note
         * @param {string} projectId Project id
         * @param {string} screenId Screen id
         * @param {string} noteId Screen note id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteScreenNote(projectId: string, screenId: string, noteId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteScreenNote(projectId, screenId, noteId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get details of the latest version
         * @summary Get the latest screen version
         * @param {string} projectId Project id
         * @param {string} screenId Screen id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLatestScreenVersion(projectId: string, screenId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLatestScreenVersion(projectId, screenId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List all screens of the project
         * @summary Get project screens
         * @param {string} projectId Project id
         * @param {string} [sectionId] Filter by section id
         * @param {'section' | 'created'} [sort] Sort screens by their &#x60;section&#x60; or their &#x60;created&#x60; date
         * @param {number} [limit] Pagination limit
         * @param {number} [offset] Pagination offset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProjectScreens(projectId: string, sectionId?: string, sort?: 'section' | 'created', limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProjectScreens(projectId, sectionId, sort, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a single screen by id
         * @summary Get a single screen
         * @param {string} projectId Project id
         * @param {string} screenId Screen id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getScreen(projectId: string, screenId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getScreen(projectId, screenId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a screen annotation by id
         * @summary Get a single screen annotation
         * @param {string} projectId Project id
         * @param {string} screenId Screen id
         * @param {string} annotationId Screen annotation id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getScreenAnnotation(projectId: string, screenId: string, annotationId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getScreenAnnotation(projectId, screenId, annotationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List all annotations in the screen
         * @summary Get screen annotations
         * @param {string} projectId Project id
         * @param {string} screenId Screen id
         * @param {number} [limit] Pagination limit
         * @param {number} [offset] Pagination offset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getScreenAnnotations(projectId: string, screenId: string, limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getScreenAnnotations(projectId, screenId, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List all annotation note types in the project
         * @summary Get screen annotation note types
         * @param {string} projectId Project id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getScreenAnnotationsNoteTypes(projectId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getScreenAnnotationsNoteTypes(projectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List all components in the screen
         * @summary Get screen components
         * @param {string} projectId Project id
         * @param {string} screenId Screen id
         * @param {number} [limit] Pagination limit
         * @param {number} [offset] Pagination offset
         * @param {boolean} [includeLatestVersion] Whether to include the latest version data in the Component object
         * @param {boolean} [includeLinkedStyleguides] Whether to include linked styleguides or not
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getScreenComponents(projectId: string, screenId: string, limit?: number, offset?: number, includeLatestVersion?: boolean, includeLinkedStyleguides?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getScreenComponents(projectId, screenId, limit, offset, includeLatestVersion, includeLinkedStyleguides, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a screen note by id
         * @summary Get a single screen note
         * @param {string} projectId Project id
         * @param {string} screenId Screen id
         * @param {string} noteId Screen note id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getScreenNote(projectId: string, screenId: string, noteId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getScreenNote(projectId, screenId, noteId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List all notes in the screen
         * @summary Get screen notes
         * @param {string} projectId Project id
         * @param {string} screenId Screen id
         * @param {number} [limit] Pagination limit
         * @param {number} [offset] Pagination offset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getScreenNotes(projectId: string, screenId: string, limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getScreenNotes(projectId, screenId, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a screen section by id
         * @summary Get a single screen section
         * @param {string} projectId Project id
         * @param {string} sectionId Screen section id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getScreenSection(projectId: string, sectionId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getScreenSection(projectId, sectionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List all screen sections of the project
         * @summary Get screen sections
         * @param {string} projectId Project id
         * @param {number} [limit] Pagination limit
         * @param {number} [offset] Pagination offset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getScreenSections(projectId: string, limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getScreenSections(projectId, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a screen variant by id
         * @summary Get a single screen variant
         * @param {string} projectId Project id
         * @param {string} variantId Screen variant id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getScreenVariant(projectId: string, variantId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getScreenVariant(projectId, variantId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List all screen variants of the project
         * @summary Get screen variants
         * @param {string} projectId Project id
         * @param {number} [limit] Pagination limit
         * @param {number} [offset] Pagination offset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getScreenVariants(projectId: string, limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getScreenVariants(projectId, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get details of the screen version
         * @summary Get a single screen version
         * @param {string} projectId Project id
         * @param {string} screenId Screen id
         * @param {string} versionId Screen version id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getScreenVersion(projectId: string, screenId: string, versionId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getScreenVersion(projectId, screenId, versionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List all versions of the screen in a project
         * @summary Get screen versions
         * @param {string} projectId Project id
         * @param {string} screenId Screen id
         * @param {number} [limit] Pagination limit
         * @param {number} [offset] Pagination offset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getScreenVersions(projectId: string, screenId: string, limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getScreenVersions(projectId, screenId, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a screen\'s description
         * @summary Update a screen
         * @param {string} projectId Project id
         * @param {string} screenId Screen id
         * @param {ScreenUpdateBody} screenUpdateBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateScreen(projectId: string, screenId: string, screenUpdateBody: ScreenUpdateBody, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateScreen(projectId, screenId, screenUpdateBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update an annotation on the screen
         * @summary Update an annotation
         * @param {string} projectId Project id
         * @param {string} screenId Screen id
         * @param {string} annotationId Screen annotation id
         * @param {ScreenAnnotationUpdateBody} screenAnnotationUpdateBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateScreenAnnotation(projectId: string, screenId: string, annotationId: string, screenAnnotationUpdateBody: ScreenAnnotationUpdateBody, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateScreenAnnotation(projectId, screenId, annotationId, screenAnnotationUpdateBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update comments on the screen note
         * @summary Update comment
         * @param {string} projectId Project id
         * @param {string} screenId Screen id
         * @param {string} noteId Screen note id
         * @param {string} commentId Screen comment id
         * @param {CommentUpdateBody} commentUpdateBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateScreenComment(projectId: string, screenId: string, noteId: string, commentId: string, commentUpdateBody: CommentUpdateBody, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateScreenComment(projectId, screenId, noteId, commentId, commentUpdateBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a note on the screen
         * @summary Update a note
         * @param {string} projectId Project id
         * @param {string} screenId Screen id
         * @param {string} noteId Screen note id
         * @param {ScreenNoteUpdateBody} screenNoteUpdateBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateScreenNote(projectId: string, screenId: string, noteId: string, screenNoteUpdateBody: ScreenNoteUpdateBody, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateScreenNote(projectId, screenId, noteId, screenNoteUpdateBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};


/**
 * Body for createScreen operation in ScreensApi.
 * @export
 * @interface ScreensApiCreateScreenBody
 */
export interface ScreensApiCreateScreenBody {
    /**
     * Name of the screen
     * @type {string}
     * @memberof ScreensApiCreateScreenBody
     */
    readonly name: string;

    /**
     * Binary data of the screen image.  The image has to be in JPEG or PNG format, and its size cannot exceed 5MB. 
     * @type {{ file: any, type: "jpeg" | "png" }}
     * @memberof ScreensApiCreateScreenBody
     */
    readonly image: {
        file: any,
        type: "jpeg" | "png"
    };

    /**
     * Description for the screen
     * @type {string}
     * @memberof ScreensApiCreateScreenBody
     */
    readonly description?: string;

    /**
     * Commit message for the screen version
     * @type {string}
     * @memberof ScreensApiCreateScreenBody
     */
    readonly commitMessage?: string;

    /**
     * Commit color for the screen version
     * @type {string}
     * @memberof ScreensApiCreateScreenBody
     */
    readonly commitColor?: string;

    /**
     * Tags for the screen
     * @type {Array<string>}
     * @memberof ScreensApiCreateScreenBody
     */
    readonly tags?: Array<string>;

    /**
     * Unique id of the screen section
     * @type {string}
     * @memberof ScreensApiCreateScreenBody
     */
    readonly sectionId?: string;
}




/**
 * Body for createScreenVersion operation in ScreensApi.
 * @export
 * @interface ScreensApiCreateScreenVersionBody
 */
export interface ScreensApiCreateScreenVersionBody {
    /**
     * Binary data of the screen image.  The image has to be in JPEG or PNG format, and its size cannot exceed 5MB. 
     * @type {{ file: any, type: "jpeg" | "png" }}
     * @memberof ScreensApiCreateScreenVersionBody
     */
    readonly image: {
        file: any,
        type: "jpeg" | "png"
    };

    /**
     * Commit message for the screen version
     * @type {string}
     * @memberof ScreensApiCreateScreenVersionBody
     */
    readonly commitMessage?: string;

    /**
     * Commit color for the screen version
     * @type {string}
     * @memberof ScreensApiCreateScreenVersionBody
     */
    readonly commitColor?: string;
}





/**
 * Search parameters for getProjectScreens operation in ScreensApi.
 * @export
 * @interface ScreensApiGetProjectScreensSearchParams
 */
export interface ScreensApiGetProjectScreensSearchParams {
    /**
     * Filter by section id
     * @type {string}
     * @memberof ScreensApiGetProjectScreensSearchParams
     */
    readonly sectionId?: string;

    /**
     * Sort screens by their &#x60;section&#x60; or their &#x60;created&#x60; date
     * @type {'section' | 'created'}
     * @memberof ScreensApiGetProjectScreensSearchParams
     */
    readonly sort?: 'section' | 'created';

    /**
     * Pagination limit
     * @type {number}
     * @memberof ScreensApiGetProjectScreensSearchParams
     */
    readonly limit?: number;

    /**
     * Pagination offset
     * @type {number}
     * @memberof ScreensApiGetProjectScreensSearchParams
     */
    readonly offset?: number;
}



/**
 * Search parameters for getScreenAnnotations operation in ScreensApi.
 * @export
 * @interface ScreensApiGetScreenAnnotationsSearchParams
 */
export interface ScreensApiGetScreenAnnotationsSearchParams {
    /**
     * Pagination limit
     * @type {number}
     * @memberof ScreensApiGetScreenAnnotationsSearchParams
     */
    readonly limit?: number;

    /**
     * Pagination offset
     * @type {number}
     * @memberof ScreensApiGetScreenAnnotationsSearchParams
     */
    readonly offset?: number;
}


/**
 * Search parameters for getScreenComponents operation in ScreensApi.
 * @export
 * @interface ScreensApiGetScreenComponentsSearchParams
 */
export interface ScreensApiGetScreenComponentsSearchParams {
    /**
     * Pagination limit
     * @type {number}
     * @memberof ScreensApiGetScreenComponentsSearchParams
     */
    readonly limit?: number;

    /**
     * Pagination offset
     * @type {number}
     * @memberof ScreensApiGetScreenComponentsSearchParams
     */
    readonly offset?: number;

    /**
     * Whether to include the latest version data in the Component object
     * @type {boolean}
     * @memberof ScreensApiGetScreenComponentsSearchParams
     */
    readonly includeLatestVersion?: boolean;

    /**
     * Whether to include linked styleguides or not
     * @type {boolean}
     * @memberof ScreensApiGetScreenComponentsSearchParams
     */
    readonly includeLinkedStyleguides?: boolean;
}


/**
 * Search parameters for getScreenNotes operation in ScreensApi.
 * @export
 * @interface ScreensApiGetScreenNotesSearchParams
 */
export interface ScreensApiGetScreenNotesSearchParams {
    /**
     * Pagination limit
     * @type {number}
     * @memberof ScreensApiGetScreenNotesSearchParams
     */
    readonly limit?: number;

    /**
     * Pagination offset
     * @type {number}
     * @memberof ScreensApiGetScreenNotesSearchParams
     */
    readonly offset?: number;
}


/**
 * Search parameters for getScreenSections operation in ScreensApi.
 * @export
 * @interface ScreensApiGetScreenSectionsSearchParams
 */
export interface ScreensApiGetScreenSectionsSearchParams {
    /**
     * Pagination limit
     * @type {number}
     * @memberof ScreensApiGetScreenSectionsSearchParams
     */
    readonly limit?: number;

    /**
     * Pagination offset
     * @type {number}
     * @memberof ScreensApiGetScreenSectionsSearchParams
     */
    readonly offset?: number;
}


/**
 * Search parameters for getScreenVariants operation in ScreensApi.
 * @export
 * @interface ScreensApiGetScreenVariantsSearchParams
 */
export interface ScreensApiGetScreenVariantsSearchParams {
    /**
     * Pagination limit
     * @type {number}
     * @memberof ScreensApiGetScreenVariantsSearchParams
     */
    readonly limit?: number;

    /**
     * Pagination offset
     * @type {number}
     * @memberof ScreensApiGetScreenVariantsSearchParams
     */
    readonly offset?: number;
}


/**
 * Search parameters for getScreenVersions operation in ScreensApi.
 * @export
 * @interface ScreensApiGetScreenVersionsSearchParams
 */
export interface ScreensApiGetScreenVersionsSearchParams {
    /**
     * Pagination limit
     * @type {number}
     * @memberof ScreensApiGetScreenVersionsSearchParams
     */
    readonly limit?: number;

    /**
     * Pagination offset
     * @type {number}
     * @memberof ScreensApiGetScreenVersionsSearchParams
     */
    readonly offset?: number;
}






/**
 * ScreensApi - object-oriented interface
 * @export
 * @class ScreensApi
 * @extends {BaseAPI}
 */
export class ScreensApi extends BaseAPI {
    /**
     * Create a new screen in the project
     * @summary Create a new screen
     * @param {string} projectId Project id
     * @param {string} name Name of the screen
     * @param {any} image Binary data of the screen image.  The image has to be in JPEG or PNG format, and its size cannot exceed 5MB. 
     * @param {string} [description] Description for the screen
     * @param {string} [commitMessage] Commit message for the screen version
     * @param {string} [commitColor] Commit color for the screen version
     * @param {Array<string>} [tags] Tags for the screen
     * @param {string} [sectionId] Unique id of the screen section
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScreensApi
     */
    public async createScreen(projectId: string, multipartParams: ScreensApiCreateScreenBody, options?: any) : Promise<AxiosResponse<EntityReference>> {
        const screensApiFp = ScreensApiFp(this.configuration);
        const request = await screensApiFp.createScreen(projectId, multipartParams.name, multipartParams.image, multipartParams.description, multipartParams.commitMessage, multipartParams.commitColor, multipartParams.tags, multipartParams.sectionId, options);
        const response = await request(this.axios, this.basePath);
        return {
            ...response,
            data: transformJSONToEntityReference(response.data)
        };
    }

    /**
     * Create an annotation on the screen
     * @summary Create an annotation
     * @param {string} projectId Project id
     * @param {string} screenId Screen id
     * @param {ScreenAnnotationCreateBody} screenAnnotationCreateBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScreensApi
     */
    public async createScreenAnnotation(projectId: string, screenId: string, screenAnnotationCreateBody: ScreenAnnotationCreateBody, options?: any) : Promise<AxiosResponse<EntityReference>> {
        const screensApiFp = ScreensApiFp(this.configuration);
        const request = await screensApiFp.createScreenAnnotation(projectId, screenId, screenAnnotationCreateBody, options);
        const response = await request(this.axios, this.basePath);
        return {
            ...response,
            data: transformJSONToEntityReference(response.data)
        };
    }

    /**
     * Create comment on the screen note
     * @summary Create a comment
     * @param {string} projectId Project id
     * @param {string} screenId Screen id
     * @param {string} noteId Screen note id
     * @param {CommentCreateBody} commentCreateBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScreensApi
     */
    public async createScreenComment(projectId: string, screenId: string, noteId: string, commentCreateBody: CommentCreateBody, options?: any) : Promise<AxiosResponse<EntityReference>> {
        const screensApiFp = ScreensApiFp(this.configuration);
        const request = await screensApiFp.createScreenComment(projectId, screenId, noteId, commentCreateBody, options);
        const response = await request(this.axios, this.basePath);
        return {
            ...response,
            data: transformJSONToEntityReference(response.data)
        };
    }

    /**
     * Create a note on the screen
     * @summary Create a note
     * @param {string} projectId Project id
     * @param {string} screenId Screen id
     * @param {ScreenNoteCreateBody} screenNoteCreateBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScreensApi
     */
    public async createScreenNote(projectId: string, screenId: string, screenNoteCreateBody: ScreenNoteCreateBody, options?: any) : Promise<AxiosResponse<EntityReference>> {
        const screensApiFp = ScreensApiFp(this.configuration);
        const request = await screensApiFp.createScreenNote(projectId, screenId, screenNoteCreateBody, options);
        const response = await request(this.axios, this.basePath);
        return {
            ...response,
            data: transformJSONToEntityReference(response.data)
        };
    }

    /**
     * Create a new screen version in the project
     * @summary Create a new screen version
     * @param {string} projectId Project id
     * @param {string} screenId Screen id
     * @param {any} image Binary data of the screen image.  The image has to be in JPEG or PNG format, and its size cannot exceed 5MB. 
     * @param {string} [commitMessage] Commit message for the screen version
     * @param {string} [commitColor] Commit color for the screen version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScreensApi
     */
    public async createScreenVersion(projectId: string, screenId: string, multipartParams: ScreensApiCreateScreenVersionBody, options?: any) : Promise<AxiosResponse<EntityReference>> {
        const screensApiFp = ScreensApiFp(this.configuration);
        const request = await screensApiFp.createScreenVersion(projectId, screenId, multipartParams.image, multipartParams.commitMessage, multipartParams.commitColor, options);
        const response = await request(this.axios, this.basePath);
        return {
            ...response,
            data: transformJSONToEntityReference(response.data)
        };
    }

    /**
     * Delete an annotation on the screen
     * @summary Delete an annotation
     * @param {string} projectId Project id
     * @param {string} screenId Screen id
     * @param {string} annotationId Screen annotation id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScreensApi
     */
    public async deleteScreenAnnotation(projectId: string, screenId: string, annotationId: string, options?: any) : Promise<AxiosResponse<void>> {
        const screensApiFp = ScreensApiFp(this.configuration);
        const request = await screensApiFp.deleteScreenAnnotation(projectId, screenId, annotationId, options);
        const response = await request(this.axios, this.basePath);
        return response;
    }

    /**
     * Delete a comment on the screen note
     * @summary Delete comment
     * @param {string} projectId Project id
     * @param {string} screenId Screen id
     * @param {string} noteId Screen note id
     * @param {string} commentId Screen comment id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScreensApi
     */
    public async deleteScreenComment(projectId: string, screenId: string, noteId: string, commentId: string, options?: any) : Promise<AxiosResponse<void>> {
        const screensApiFp = ScreensApiFp(this.configuration);
        const request = await screensApiFp.deleteScreenComment(projectId, screenId, noteId, commentId, options);
        const response = await request(this.axios, this.basePath);
        return response;
    }

    /**
     * Delete a note on the screen
     * @summary Delete a note
     * @param {string} projectId Project id
     * @param {string} screenId Screen id
     * @param {string} noteId Screen note id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScreensApi
     */
    public async deleteScreenNote(projectId: string, screenId: string, noteId: string, options?: any) : Promise<AxiosResponse<void>> {
        const screensApiFp = ScreensApiFp(this.configuration);
        const request = await screensApiFp.deleteScreenNote(projectId, screenId, noteId, options);
        const response = await request(this.axios, this.basePath);
        return response;
    }

    /**
     * Get details of the latest version
     * @summary Get the latest screen version
     * @param {string} projectId Project id
     * @param {string} screenId Screen id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScreensApi
     */
    public async getLatestScreenVersion(projectId: string, screenId: string, options?: any) : Promise<AxiosResponse<ScreenVersion>> {
        const screensApiFp = ScreensApiFp(this.configuration);
        const request = await screensApiFp.getLatestScreenVersion(projectId, screenId, options);
        const response = await request(this.axios, this.basePath);
        return {
            ...response,
            data: transformJSONToScreenVersion(response.data)
        };
    }

    /**
     * List all screens of the project
     * @summary Get project screens
     * @param {string} projectId Project id
     * @param {ScreensApiGetProjectScreensSearchParams} [searchParams] Search parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScreensApi
     */
    public async getProjectScreens(projectId: string, searchParams: ScreensApiGetProjectScreensSearchParams = {}, options?: any) : Promise<AxiosResponse<Array<Screen>>> {
        const screensApiFp = ScreensApiFp(this.configuration);
        const request = await screensApiFp.getProjectScreens(projectId, searchParams.sectionId, searchParams.sort, searchParams.limit, searchParams.offset, options);
        const response = await request(this.axios, this.basePath);
        return {
            ...response,
            data: response.data.map(transformJSONToScreen)
        };
    }

    /**
     * Get a single screen by id
     * @summary Get a single screen
     * @param {string} projectId Project id
     * @param {string} screenId Screen id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScreensApi
     */
    public async getScreen(projectId: string, screenId: string, options?: any) : Promise<AxiosResponse<Screen>> {
        const screensApiFp = ScreensApiFp(this.configuration);
        const request = await screensApiFp.getScreen(projectId, screenId, options);
        const response = await request(this.axios, this.basePath);
        return {
            ...response,
            data: transformJSONToScreen(response.data)
        };
    }

    /**
     * Get a screen annotation by id
     * @summary Get a single screen annotation
     * @param {string} projectId Project id
     * @param {string} screenId Screen id
     * @param {string} annotationId Screen annotation id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScreensApi
     */
    public async getScreenAnnotation(projectId: string, screenId: string, annotationId: string, options?: any) : Promise<AxiosResponse<ScreenAnnotation>> {
        const screensApiFp = ScreensApiFp(this.configuration);
        const request = await screensApiFp.getScreenAnnotation(projectId, screenId, annotationId, options);
        const response = await request(this.axios, this.basePath);
        return {
            ...response,
            data: transformJSONToScreenAnnotation(response.data)
        };
    }

    /**
     * List all annotations in the screen
     * @summary Get screen annotations
     * @param {string} projectId Project id
     * @param {string} screenId Screen id
     * @param {ScreensApiGetScreenAnnotationsSearchParams} [searchParams] Search parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScreensApi
     */
    public async getScreenAnnotations(projectId: string, screenId: string, searchParams: ScreensApiGetScreenAnnotationsSearchParams = {}, options?: any) : Promise<AxiosResponse<Array<ScreenAnnotation>>> {
        const screensApiFp = ScreensApiFp(this.configuration);
        const request = await screensApiFp.getScreenAnnotations(projectId, screenId, searchParams.limit, searchParams.offset, options);
        const response = await request(this.axios, this.basePath);
        return {
            ...response,
            data: response.data.map(transformJSONToScreenAnnotation)
        };
    }

    /**
     * List all annotation note types in the project
     * @summary Get screen annotation note types
     * @param {string} projectId Project id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScreensApi
     */
    public async getScreenAnnotationsNoteTypes(projectId: string, options?: any) : Promise<AxiosResponse<Array<ScreenAnnotationNoteType>>> {
        const screensApiFp = ScreensApiFp(this.configuration);
        const request = await screensApiFp.getScreenAnnotationsNoteTypes(projectId, options);
        const response = await request(this.axios, this.basePath);
        return {
            ...response,
            data: response.data.map(transformJSONToScreenAnnotationNoteType)
        };
    }

    /**
     * List all components in the screen
     * @summary Get screen components
     * @param {string} projectId Project id
     * @param {string} screenId Screen id
     * @param {ScreensApiGetScreenComponentsSearchParams} [searchParams] Search parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScreensApi
     */
    public async getScreenComponents(projectId: string, screenId: string, searchParams: ScreensApiGetScreenComponentsSearchParams = {}, options?: any) : Promise<AxiosResponse<Array<Component>>> {
        const screensApiFp = ScreensApiFp(this.configuration);
        const request = await screensApiFp.getScreenComponents(projectId, screenId, searchParams.limit, searchParams.offset, searchParams.includeLatestVersion, searchParams.includeLinkedStyleguides, options);
        const response = await request(this.axios, this.basePath);
        return {
            ...response,
            data: response.data.map(transformJSONToComponent)
        };
    }

    /**
     * Get a screen note by id
     * @summary Get a single screen note
     * @param {string} projectId Project id
     * @param {string} screenId Screen id
     * @param {string} noteId Screen note id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScreensApi
     */
    public async getScreenNote(projectId: string, screenId: string, noteId: string, options?: any) : Promise<AxiosResponse<ScreenNote>> {
        const screensApiFp = ScreensApiFp(this.configuration);
        const request = await screensApiFp.getScreenNote(projectId, screenId, noteId, options);
        const response = await request(this.axios, this.basePath);
        return {
            ...response,
            data: transformJSONToScreenNote(response.data)
        };
    }

    /**
     * List all notes in the screen
     * @summary Get screen notes
     * @param {string} projectId Project id
     * @param {string} screenId Screen id
     * @param {ScreensApiGetScreenNotesSearchParams} [searchParams] Search parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScreensApi
     */
    public async getScreenNotes(projectId: string, screenId: string, searchParams: ScreensApiGetScreenNotesSearchParams = {}, options?: any) : Promise<AxiosResponse<Array<ScreenNote>>> {
        const screensApiFp = ScreensApiFp(this.configuration);
        const request = await screensApiFp.getScreenNotes(projectId, screenId, searchParams.limit, searchParams.offset, options);
        const response = await request(this.axios, this.basePath);
        return {
            ...response,
            data: response.data.map(transformJSONToScreenNote)
        };
    }

    /**
     * Get a screen section by id
     * @summary Get a single screen section
     * @param {string} projectId Project id
     * @param {string} sectionId Screen section id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScreensApi
     */
    public async getScreenSection(projectId: string, sectionId: string, options?: any) : Promise<AxiosResponse<ScreenSection>> {
        const screensApiFp = ScreensApiFp(this.configuration);
        const request = await screensApiFp.getScreenSection(projectId, sectionId, options);
        const response = await request(this.axios, this.basePath);
        return {
            ...response,
            data: transformJSONToScreenSection(response.data)
        };
    }

    /**
     * List all screen sections of the project
     * @summary Get screen sections
     * @param {string} projectId Project id
     * @param {ScreensApiGetScreenSectionsSearchParams} [searchParams] Search parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScreensApi
     */
    public async getScreenSections(projectId: string, searchParams: ScreensApiGetScreenSectionsSearchParams = {}, options?: any) : Promise<AxiosResponse<Array<ScreenSection>>> {
        const screensApiFp = ScreensApiFp(this.configuration);
        const request = await screensApiFp.getScreenSections(projectId, searchParams.limit, searchParams.offset, options);
        const response = await request(this.axios, this.basePath);
        return {
            ...response,
            data: response.data.map(transformJSONToScreenSection)
        };
    }

    /**
     * Get a screen variant by id
     * @summary Get a single screen variant
     * @param {string} projectId Project id
     * @param {string} variantId Screen variant id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScreensApi
     */
    public async getScreenVariant(projectId: string, variantId: string, options?: any) : Promise<AxiosResponse<ScreenVariantGroup>> {
        const screensApiFp = ScreensApiFp(this.configuration);
        const request = await screensApiFp.getScreenVariant(projectId, variantId, options);
        const response = await request(this.axios, this.basePath);
        return {
            ...response,
            data: transformJSONToScreenVariantGroup(response.data)
        };
    }

    /**
     * List all screen variants of the project
     * @summary Get screen variants
     * @param {string} projectId Project id
     * @param {ScreensApiGetScreenVariantsSearchParams} [searchParams] Search parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScreensApi
     */
    public async getScreenVariants(projectId: string, searchParams: ScreensApiGetScreenVariantsSearchParams = {}, options?: any) : Promise<AxiosResponse<Array<ScreenVariantGroup>>> {
        const screensApiFp = ScreensApiFp(this.configuration);
        const request = await screensApiFp.getScreenVariants(projectId, searchParams.limit, searchParams.offset, options);
        const response = await request(this.axios, this.basePath);
        return {
            ...response,
            data: response.data.map(transformJSONToScreenVariantGroup)
        };
    }

    /**
     * Get details of the screen version
     * @summary Get a single screen version
     * @param {string} projectId Project id
     * @param {string} screenId Screen id
     * @param {string} versionId Screen version id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScreensApi
     */
    public async getScreenVersion(projectId: string, screenId: string, versionId: string, options?: any) : Promise<AxiosResponse<ScreenVersion>> {
        const screensApiFp = ScreensApiFp(this.configuration);
        const request = await screensApiFp.getScreenVersion(projectId, screenId, versionId, options);
        const response = await request(this.axios, this.basePath);
        return {
            ...response,
            data: transformJSONToScreenVersion(response.data)
        };
    }

    /**
     * List all versions of the screen in a project
     * @summary Get screen versions
     * @param {string} projectId Project id
     * @param {string} screenId Screen id
     * @param {ScreensApiGetScreenVersionsSearchParams} [searchParams] Search parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScreensApi
     */
    public async getScreenVersions(projectId: string, screenId: string, searchParams: ScreensApiGetScreenVersionsSearchParams = {}, options?: any) : Promise<AxiosResponse<Array<ScreenVersionSummary>>> {
        const screensApiFp = ScreensApiFp(this.configuration);
        const request = await screensApiFp.getScreenVersions(projectId, screenId, searchParams.limit, searchParams.offset, options);
        const response = await request(this.axios, this.basePath);
        return {
            ...response,
            data: response.data.map(transformJSONToScreenVersionSummary)
        };
    }

    /**
     * Update a screen\'s description
     * @summary Update a screen
     * @param {string} projectId Project id
     * @param {string} screenId Screen id
     * @param {ScreenUpdateBody} screenUpdateBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScreensApi
     */
    public async updateScreen(projectId: string, screenId: string, screenUpdateBody: ScreenUpdateBody, options?: any) : Promise<AxiosResponse<void>> {
        const screensApiFp = ScreensApiFp(this.configuration);
        const request = await screensApiFp.updateScreen(projectId, screenId, screenUpdateBody, options);
        const response = await request(this.axios, this.basePath);
        return response;
    }

    /**
     * Update an annotation on the screen
     * @summary Update an annotation
     * @param {string} projectId Project id
     * @param {string} screenId Screen id
     * @param {string} annotationId Screen annotation id
     * @param {ScreenAnnotationUpdateBody} screenAnnotationUpdateBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScreensApi
     */
    public async updateScreenAnnotation(projectId: string, screenId: string, annotationId: string, screenAnnotationUpdateBody: ScreenAnnotationUpdateBody, options?: any) : Promise<AxiosResponse<void>> {
        const screensApiFp = ScreensApiFp(this.configuration);
        const request = await screensApiFp.updateScreenAnnotation(projectId, screenId, annotationId, screenAnnotationUpdateBody, options);
        const response = await request(this.axios, this.basePath);
        return response;
    }

    /**
     * Update comments on the screen note
     * @summary Update comment
     * @param {string} projectId Project id
     * @param {string} screenId Screen id
     * @param {string} noteId Screen note id
     * @param {string} commentId Screen comment id
     * @param {CommentUpdateBody} commentUpdateBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScreensApi
     */
    public async updateScreenComment(projectId: string, screenId: string, noteId: string, commentId: string, commentUpdateBody: CommentUpdateBody, options?: any) : Promise<AxiosResponse<void>> {
        const screensApiFp = ScreensApiFp(this.configuration);
        const request = await screensApiFp.updateScreenComment(projectId, screenId, noteId, commentId, commentUpdateBody, options);
        const response = await request(this.axios, this.basePath);
        return response;
    }

    /**
     * Update a note on the screen
     * @summary Update a note
     * @param {string} projectId Project id
     * @param {string} screenId Screen id
     * @param {string} noteId Screen note id
     * @param {ScreenNoteUpdateBody} screenNoteUpdateBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScreensApi
     */
    public async updateScreenNote(projectId: string, screenId: string, noteId: string, screenNoteUpdateBody: ScreenNoteUpdateBody, options?: any) : Promise<AxiosResponse<void>> {
        const screensApiFp = ScreensApiFp(this.configuration);
        const request = await screensApiFp.updateScreenNote(projectId, screenId, noteId, screenNoteUpdateBody, options);
        const response = await request(this.axios, this.basePath);
        return response;
    }
}
